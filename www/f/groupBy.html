<!DOCTYPE html>
<html>
  <head>
    <title>groupBy</title>
    <link rel="stylesheet" type="text/css" href="../jsoncalc.css">
    <meta name="description" content="jsoncalc groupBy - Split a table into groups">
    <meta name="keywords" content="array, jsoncalc, function reference, groupBy">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <h1>groupBy - Split a table into groups</h1>
    <dl>
      <dt>groupBy(<var>table</var><span class="type">:table</span>, <var>columns</var><span class="type">:array|string</span>, <var>totals</var><span class="type">?:string</span>) <span class="type">:array</span>
      <dd>
      This splits a table (array of objects) into segments, based on the values of the <var>columns</var> members.  The result is an array of arrays of objects.
      <p>
      This is useful mostly as a way to affect the scope of aggregate functions when used with
      the @ and @@ operators.
      For example, if you have a table of sales data which contains a "region" column
      (meaning each row/element/object has a "region" member)
      then you might want to group them by region so you could report the regional
      totals or averages.
      (Yes, this corresponds to the SQL "GROUP BY" clause.)
      <p>
      The <var>table</var> is simply an array of objects.
      Each element is a row, and then members of the rows' objects serve as columns.
      <p>
      The <var>columns</var> list is an array of strings, corresponding to the object
      member keys (column names).
      For the sake of convenience, if you just want to group by a single column,
      you can just pass its name as a string, instead of an array of strings.
      <p>
      In order to form the groups, this function sorts the table.
      The main difference between <tt>groupBy()</tt> and
      <a target="_PARENT" href="../index.html?f=orderBy">orderBy()</a>
      is that <tt>groupBy()</tt> forms subarrays that contain rows that share
      the same values for the named <var>columns</var>, while
      <a target="_PARENT" href="../index.html?f=orderBy">orderBy()</a>
      keeps them separate.
      <p>
      If you pass a <var>totals</var> parameter, then <tt>groupBy()</tt> will
      append an extra object to the end of the response array, containing a
      single member with first name from the <var>columns</var> parameter as
      the member's key (name), and the <var>totals</var> value as its value.
      Due to the way @ and @@ interact with aggregates, this causes any columns
      that use aggregate functions to apply those functions across all rows
      instead of splitting by the group.
      This makes it easy to get combined totals.
    </dl>
    <details open>
      <summary>Examples</summary>

      <div class="example">
	<kbd>groupBy(test.scores, "run")@{run,avg(score)}</kbd>
	<samp>
	  <table>
	    <tr><th>run</th><th>avg(score)</th></tr>
	    <tr><td>1</td><td>20</td></tr>
	    <tr><td>2</td><td>30</td></tr>
	    <tr><td>3</td><td>31.6666666667</td></tr>
	  </table>
	</samp>
	Group "test.scores" table rows by "run".
	The @ operator outputs one record per group, in this case containing the
	run number and the average score within that run.
      </div>

      <div class="example">
	<kbd>test.scores.groupBy("name","OVERALL")@{name,avg(score)}</kbd>
	<samp>
	  <table>
	    <tr><th>name</th><th>avg(score)</th></tr>
	    <tr><td>Mary</td><td>35</td></tr>
	    <tr><td>Paul</td><td>25</td></tr>
	    <tr><td>Peter</td><td>21.6666666667</td></tr>
	    <tr><td>OVERALL</td><td>27.2222222222</td></tr>
	  </table>
	</samp>
	This time we're grouping by "name" instead of "run".
	Although "test.scores" is sorted by "run", the <tt>groupBy()</tt>
	function will sort it by "name" for the sake of grouping.
	Also, we added "OVERALL" as a <var>totals</var> label,
	so we got a row for the overall average too.
      </div>

      <div class="example">
	<kbd>test.scores.groupBy("run") @@ score&lt;avg(score)</kbd>
	<samp>
	  <table>
	    <tr><th>name</th><th>run</th><th>score</th></tr>
	    <tr><td>Peter</td><td>1</td><td>10</td></tr>
	    <tr><td>Peter</td><td>2</td><td>25</td></tr>
	    <tr><td>Peter</td><td>3</td><td>30</td></tr>
	    <tr><td>Paul</td><td>3</td><td>25</td></tr>
	  </table>
	</samp>
	The difference between @ and @@ is that @ outputs one row per group, while
	@@ outputs one row per row.
	We're using @@ here to list the name, run, and score
	of anybody who got less than the average score for their run.
	Note that we got two rows from run 3.
      </div>

    </details>

    <details>
      <summary>Notes</summary>
      <ul>

        <li>The result of <tt>groupBy()</tt> is no longer a table.
            Instead, it is an array of tables, possibly with an oddball
            "totals" object added in.
            The @ and @@ operators work with this, and will reassemble the
            results as a table again.

        <li>If you're using the
            <a target="_PARENT" href="../index.html?f=count">count()</a>
            aggregate function together with a "totals" line, then for the
            argument to <tt>count()</tt> you should use the name of a
            column (member) that will be null for the totals row but not
            for any actual data rows.
            If you just use <tt>count(*)</tt> then the total row will be
            included in the count.

      </ul>
    </details>
  </body>
</html>
